<?php

declare(strict_types=1);

namespace MonkeysLegion\Cli;

use MonkeysLegion\Cli\Console\Attributes\Command as CommandAttr;
use MonkeysLegion\Cli\Console\Command;
use MonkeysLegion\Cli\Console\Traits\Cli;
use Psr\Container\ContainerInterface;
use ReflectionClass;
use ReflectionException;

/**
 * Attribute-driven CLI kernel with prefix-based command grouping.
 *  • Accepts an iterable list of command FQCNs (auto-generated by CommandFinder)
 *  • Also scans MonkeysLegion\Cli\Command\* for #[Command] attributes.
 *  • Also scans App\Cli\Command\* for application commands.
 *  • Groups commands by prefix (e.g., 'db:', 'make:', 'schema:')
 */
final class CliKernel
{
    use Cli;

    /** @var array<string, class-string<Command>> signature ⇒ class */
    private array $map = [];

    /** @var array<string, array<string, class-string<Command>>> prefix ⇒ [name ⇒ class] */
    private array $groupedCommands = [];

    /** @var array<string> Errors encountered during command loading */
    private array $loadingErrors = [];

    /**
     * CliKernel constructor.
     *
     * @param ContainerInterface $container Dependency injection container
     * @param iterable<class-string<Command>> $commands Explicitly passed command classes
     * @throws ReflectionException
     */
    public function __construct(
        private ContainerInterface $container,
        iterable $commands = [],
    ) {
        // 1. Register commands that were passed explicitly (from CommandFinder)
        try {
            foreach ($commands as $class) {
                try {
                    $this->register($class);
                } catch (\Throwable $e) {
                    $this->loadingErrors[] = "Failed to register command '{$class}': {$e->getMessage()}";
                }
            }
        } catch (\Throwable $e) {
            $this->loadingErrors[] = "Error loading explicit commands: {$e->getMessage()}";
        }

        // 2. Auto-discover vendor commands (MonkeysLegion\Cli\Command\*)
        try {
            $files = glob(__DIR__ . '/Command/*.php') ?: [];
            foreach ($files as $file) {
                try {
                    require_once $file;
                } catch (\Throwable $e) {
                    $this->loadingErrors[] = "Failed to load vendor command file '" . basename($file) . "': {$e->getMessage()}";
                }
            }

            foreach (get_declared_classes() as $class) {
                if (
                    str_starts_with($class, 'MonkeysLegion\\Cli\\Command\\') &&
                    is_subclass_of($class, Command::class)
                ) {
                    try {
                        /** @var class-string<Command> $class */
                        $this->register($class);
                    } catch (\Throwable $e) {
                        $this->loadingErrors[] = "Failed to register vendor command '{$class}': {$e->getMessage()}";
                    }
                }
            }
        } catch (\Throwable $e) {
            $this->loadingErrors[] = "Error discovering vendor commands: {$e->getMessage()}";
        }

        // 3. Auto-discover application commands (App\Cli\Command\*)
        try {
            $appCommandDir = base_path('app/Cli/Command');
            if (is_dir($appCommandDir)) {
                $appFiles = glob($appCommandDir . '/*.php') ?: [];
                foreach ($appFiles as $file) {
                    try {
                        require_once $file;
                    } catch (\Throwable $e) {
                        $this->loadingErrors[] = "Failed to load app command file '" . basename($file) . "': {$e->getMessage()}";
                    }
                }

                foreach (get_declared_classes() as $class) {
                    if (
                        str_starts_with($class, 'App\\Cli\\Command\\') &&
                        is_subclass_of($class, Command::class)
                    ) {
                        try {
                            /** @var class-string<Command> $class */
                            $this->register($class);
                        } catch (\Throwable $e) {
                            $this->loadingErrors[] = "Failed to register app command '{$class}': {$e->getMessage()}";
                        }
                    }
                }
            }
        } catch (\Throwable $e) {
            $this->loadingErrors[] = "Error discovering application commands: {$e->getMessage()}";
        }

        // 4. Build grouped commands by prefix
        try {
            $this->buildGroupedCommands();
        } catch (\Throwable $e) {
            $this->loadingErrors[] = "Error building command groups: {$e->getMessage()}";
        }

        // Display any loading errors
        if (!empty($this->loadingErrors)) {
            $this->displayLoadingErrors();
        }
    }

    /**
     * Register a command class if it has the #[Command] attribute.
     *
     * @param class-string<Command> $class
     * @throws ReflectionException
     */
    private function register(string $class): void
    {
        $ref   = new ReflectionClass($class);
        $attrs = $ref->getAttributes(CommandAttr::class);
        if ($attrs === []) {
            return;
        }
        /** @var CommandAttr $meta */
        $meta = $attrs[0]->newInstance();
        $this->map[$meta->signature] = $class;
    }

    /**
     * Build grouped commands organized by prefix.
     * Commands like 'db:create', 'db:drop' are grouped under 'db'.
     */
    private function buildGroupedCommands(): void
    {
        foreach ($this->map as $signature => $class) {
            if (str_contains($signature, ':')) {
                [$prefix, $name] = explode(':', $signature, 2);
                $this->groupedCommands[$prefix][$name] = $class;
            } else {
                // Commands without prefix go to 'general' group
                $this->groupedCommands['general'][$signature] = $class;
            }
        }

        // Sort groups alphabetically
        ksort($this->groupedCommands);
        foreach ($this->groupedCommands as $prefix => &$commands) {
            ksort($commands);
        }
    }

    /**
     * Display loading errors using the Cli trait.
     */
    private function displayLoadingErrors(): void
    {
        $this->cliLine()
            ->add('⚠️  Command Loading Warnings:', 'yellow', 'bold')
            ->printError();

        foreach ($this->loadingErrors as $error) {
            $this->cliLine()
                ->add('  • ', 'yellow')
                ->add($error, 'white')
                ->printError();
        }

        $this->cliLine()->plain('')->printError();
    }

    /**
     * Execute a command given argv.
     *
     * @param string[] $argv
     * @throws ReflectionException
     * @return int 0 on success, non-zero on error
     */
    public function run(array $argv): int
    {
        $sig = $argv[1] ?? 'list';

        if ($sig === 'list' || $sig === 'help') {
            $this->displayCommandList();
            return 0;
        }

        // Check if user is asking for a specific prefix group
        if (str_ends_with($sig, ':') && isset($this->groupedCommands[rtrim($sig, ':')])) {
            $this->displayPrefixCommands(rtrim($sig, ':'));
            return 0;
        }

        if (! isset($this->map[$sig])) {
            $this->cliLine()
                ->add("Command '", 'red')
                ->add($sig, 'yellow', 'bold')
                ->add("' not found.", 'red')
                ->printError();

            $this->suggestSimilarCommands($sig);
            return 1;
        }

        try {
            /** @var Command $command */
            $command = $this->container->get($this->map[$sig]);
            return $command();
        } catch (\Throwable $e) {
            $this->cliLine()
                ->add('❌ Error executing command: ', 'red', 'bold')
                ->add($e->getMessage(), 'white')
                ->printError();

            if (getenv('APP_DEBUG') === 'true') {
                $this->cliLine()
                    ->add('Stack trace:', 'gray')
                    ->printError();
                fwrite(STDERR, $e->getTraceAsString() . "\n");
            }

            return 1;
        }
    }

    /**
     * Display all available commands grouped by prefix.
     */
    private function displayCommandList(): void
    {
        $this->cliLine()
            ->add('Available Commands:', 'green', 'bold')
            ->print();

        echo str_repeat('─', 70) . "\n";

        foreach ($this->groupedCommands as $prefix => $commands) {
            $prefixLabel = $prefix === 'general' ? 'General' : ucfirst($prefix);

            $this->cliLine()
                ->plain("\n")
                ->add($prefixLabel . ':', 'yellow', 'bold')
                ->print();

            foreach ($commands as $name => $class) {
                $fullSignature = $prefix === 'general' ? $name : "{$prefix}:{$name}";

                try {
                    $ref = new ReflectionClass($class);
                    $attrs = $ref->getAttributes(CommandAttr::class);
                    if ($attrs) {
                        /** @var CommandAttr $meta */
                        $meta = $attrs[0]->newInstance();
                        $desc = $meta->description;

                        $this->cliLine()
                            ->add('  ')
                            ->add(str_pad($fullSignature, 25), 'cyan')
                            ->add($desc, 'white')
                            ->print();
                    }
                } catch (\Throwable $e) {
                    $this->cliLine()
                        ->add('  ')
                        ->add(str_pad($fullSignature, 25), 'cyan')
                        ->add('(error loading description)', 'red')
                        ->print();
                }
            }
        }

        echo "\n" . str_repeat('─', 70) . "\n";

        $this->cliLine()
            ->add("Run '", 'white')
            ->add('command-name', 'white', 'bold')
            ->add("' to execute a command.", 'white')
            ->print();

        $this->cliLine()
            ->add("Run '", 'white')
            ->add('prefix:', 'white', 'bold')
            ->add("' to see commands in a specific group (e.g., '", 'white')
            ->add('db:', 'cyan')
            ->add("', '", 'white')
            ->add('make:', 'cyan')
            ->add("').", 'white')
            ->print();

        echo "\n";
    }

    /**
     * Display commands for a specific prefix.
     *
     * @param string $prefix
     */
    private function displayPrefixCommands(string $prefix): void
    {
        if (!isset($this->groupedCommands[$prefix])) {
            $this->cliLine()
                ->add("No commands found with prefix '", 'red')
                ->add($prefix, 'yellow', 'bold')
                ->add("'", 'red')
                ->print();
            return;
        }

        $this->cliLine()
            ->add("{$prefix} Commands:", 'green', 'bold')
            ->print();

        echo str_repeat('─', 70) . "\n\n";

        foreach ($this->groupedCommands[$prefix] as $name => $class) {
            $fullSignature = "{$prefix}:{$name}";

            try {
                $ref = new ReflectionClass($class);
                $attrs = $ref->getAttributes(CommandAttr::class);
                if ($attrs) {
                    /** @var CommandAttr $meta */
                    $meta = $attrs[0]->newInstance();
                    $desc = $meta->description;

                    $this->cliLine()
                        ->add('  ')
                        ->add(str_pad($fullSignature, 25), 'cyan')
                        ->add($desc, 'white')
                        ->print();
                }
            } catch (\Throwable $e) {
                $this->cliLine()
                    ->add('  ')
                    ->add(str_pad($fullSignature, 25), 'cyan')
                    ->add('(error loading description)', 'red')
                    ->print();
            }
        }

        echo "\n" . str_repeat('─', 70) . "\n\n";
    }

    /**
     * Suggest similar commands when a command is not found.
     *
     * @param string $input
     */
    private function suggestSimilarCommands(string $input): void
    {
        $suggestions = [];
        $inputLower = strtolower($input);

        foreach (array_keys($this->map) as $signature) {
            $signatureLower = strtolower($signature);

            // Exact prefix match
            if (str_starts_with($signatureLower, $inputLower)) {
                $suggestions[] = $signature;
                continue;
            }

            // Fuzzy match using levenshtein distance
            $distance = levenshtein($inputLower, $signatureLower);
            if ($distance <= 3) {
                $suggestions[] = $signature;
            }
        }

        if (!empty($suggestions)) {
            $this->cliLine()
                ->add("\nDid you mean one of these?", 'yellow')
                ->printError();

            foreach ($suggestions as $suggestion) {
                $this->cliLine()
                    ->add('  • ', 'yellow')
                    ->add($suggestion, 'cyan')
                    ->printError();
            }
        }

        $this->cliLine()
            ->add("\nRun '", 'white')
            ->add('list', 'cyan', 'bold')
            ->add("' to see all available commands.", 'white')
            ->printError();

        echo "\n";
    }
}
