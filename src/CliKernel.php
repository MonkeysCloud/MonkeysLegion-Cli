<?php

declare(strict_types=1);

namespace MonkeysLegion\Cli;

use MonkeysLegion\Cli\Console\Attributes\Command as CommandAttr;
use MonkeysLegion\Cli\Console\Command;
use Psr\Container\ContainerInterface;
use ReflectionClass;
use ReflectionException;

/**
 * Attribute-driven CLI kernel with prefix-based command grouping.
 *  • Accepts an iterable list of command FQCNs (auto-generated by CommandFinder)
 *  • Also scans MonkeysLegion\Cli\Command\* for #[Command] attributes.
 *  • Groups commands by prefix (e.g., 'db:', 'make:', 'schema:')
 */
final class CliKernel
{
    /** @var array<string, class-string<Command>> signature ⇒ class */
    private array $map = [];

    /** @var array<string, array<string, class-string<Command>>> prefix ⇒ [name ⇒ class] */
    private array $groupedCommands = [];

    /**
     * CliKernel constructor.
     *
     * @param ContainerInterface $container Dependency injection container
     * @param iterable<class-string<Command>> $commands Explicitly passed command classes
     * @throws ReflectionException
     */
    public function __construct(
        private ContainerInterface $container,
        iterable $commands = [],
    ) {
        // 1. Register commands that were passed explicitly
        foreach ($commands as $class) {
            $this->register($class);
        }

        // 2. Fallback: auto-discover vendor commands
        $files = glob(__DIR__ . '/Command/*.php') ?: [];
        foreach ($files as $file) {
            require_once $file;
        }
        foreach (get_declared_classes() as $class) {
            if (
                str_starts_with($class, 'MonkeysLegion\\Cli\\Command\\') &&
                is_subclass_of($class, Command::class)
            ) {
                /** @var class-string<Command> $class */
                $this->register($class);
            }
        }

        // 3. Build grouped commands by prefix
        $this->buildGroupedCommands();
    }

    /**
     * Register a command class if it has the #[Command] attribute.
     *
     * @param class-string<Command> $class
     * @throws ReflectionException
     */
    private function register(string $class): void
    {
        $ref   = new ReflectionClass($class);
        $attrs = $ref->getAttributes(CommandAttr::class);
        if ($attrs === []) {
            return;
        }
        /** @var CommandAttr $meta */
        $meta = $attrs[0]->newInstance();
        $this->map[$meta->signature] = $class;
    }

    /**
     * Build grouped commands organized by prefix.
     * Commands like 'db:create', 'db:drop' are grouped under 'db'.
     */
    private function buildGroupedCommands(): void
    {
        foreach ($this->map as $signature => $class) {
            if (str_contains($signature, ':')) {
                [$prefix, $name] = explode(':', $signature, 2);
                $this->groupedCommands[$prefix][$name] = $class;
            } else {
                // Commands without prefix go to 'general' group
                $this->groupedCommands['general'][$signature] = $class;
            }
        }

        // Sort groups alphabetically
        ksort($this->groupedCommands);
        foreach ($this->groupedCommands as $prefix => &$commands) {
            ksort($commands);
        }
    }

    /**
     * Execute a command given argv.
     *
     * @param string[] $argv
     * @throws ReflectionException
     * @return int 0 on success, non-zero on error
     */
    public function run(array $argv): int
    {
        $sig = $argv[1] ?? 'list';

        if ($sig === 'list' || $sig === 'help') {
            $this->displayCommandList();
            return 0;
        }

        // Check if user is asking for a specific prefix group
        if (str_ends_with($sig, ':') && isset($this->groupedCommands[rtrim($sig, ':')])) {
            $this->displayPrefixCommands(rtrim($sig, ':'));
            return 0;
        }

        if (! isset($this->map[$sig])) {
            fwrite(STDERR, "Command '{$sig}' not found.\n");
            $this->suggestSimilarCommands($sig);
            return 1;
        }

        /** @var Command $command */
        $command = $this->container->get($this->map[$sig]);
        return $command();
    }

    /**
     * Display all available commands grouped by prefix.
     */
    private function displayCommandList(): void
    {
        echo "\n\033[1;32mAvailable Commands:\033[0m\n";
        echo str_repeat('─', 70) . "\n";

        foreach ($this->groupedCommands as $prefix => $commands) {
            $prefixLabel = $prefix === 'general' ? 'General' : ucfirst($prefix);
            echo "\n\033[1;33m{$prefixLabel}:\033[0m\n";

            foreach ($commands as $name => $class) {
                $fullSignature = $prefix === 'general' ? $name : "{$prefix}:{$name}";
                $ref = new ReflectionClass($class);
                $attrs = $ref->getAttributes(CommandAttr::class);
                if ($attrs) {
                    /** @var CommandAttr $meta */
                    $meta = $attrs[0]->newInstance();
                    $desc = $meta->description;
                    printf("  \033[0;36m%-25s\033[0m %s\n", $fullSignature, $desc);
                }
            }
        }

        echo "\n" . str_repeat('─', 70) . "\n";
        echo "Run '\033[1mcommand-name\033[0m' to execute a command.\n";
        echo "Run '\033[1mprefix:\033[0m' to see commands in a specific group (e.g., 'db:', 'make:').\n\n";
    }

    /**
     * Display commands for a specific prefix.
     *
     * @param string $prefix
     */
    private function displayPrefixCommands(string $prefix): void
    {
        if (!isset($this->groupedCommands[$prefix])) {
            echo "No commands found with prefix '{$prefix}'\n";
            return;
        }

        echo "\n\033[1;32m{$prefix} Commands:\033[0m\n";
        echo str_repeat('─', 70) . "\n\n";

        foreach ($this->groupedCommands[$prefix] as $name => $class) {
            $fullSignature = "{$prefix}:{$name}";
            $ref = new ReflectionClass($class);
            $attrs = $ref->getAttributes(CommandAttr::class);
            if ($attrs) {
                /** @var CommandAttr $meta */
                $meta = $attrs[0]->newInstance();
                $desc = $meta->description;
                printf("  \033[0;36m%-25s\033[0m %s\n", $fullSignature, $desc);
            }
        }

        echo "\n" . str_repeat('─', 70) . "\n\n";
    }

    /**
     * Suggest similar commands when a command is not found.
     *
     * @param string $input
     */
    private function suggestSimilarCommands(string $input): void
    {
        $suggestions = [];
        $inputLower = strtolower($input);

        foreach (array_keys($this->map) as $signature) {
            $signatureLower = strtolower($signature);

            // Exact prefix match
            if (str_starts_with($signatureLower, $inputLower)) {
                $suggestions[] = $signature;
                continue;
            }

            // Fuzzy match using levenshtein distance
            $distance = levenshtein($inputLower, $signatureLower);
            if ($distance <= 3) {
                $suggestions[] = $signature;
            }
        }

        if (!empty($suggestions)) {
            fwrite(STDERR, "\nDid you mean one of these?\n");
            foreach ($suggestions as $suggestion) {
                fwrite(STDERR, "  • {$suggestion}\n");
            }
        }

        fwrite(STDERR, "\nRun 'list' to see all available commands.\n");
    }
}
