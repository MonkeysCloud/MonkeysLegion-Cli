<?php

declare(strict_types=1);

namespace MonkeysLegion\Cli;

use MonkeysLegion\Cli\Console\Attributes\Command as CommandAttr;
use MonkeysLegion\Cli\Console\Command;
use Psr\Container\ContainerInterface;
use ReflectionClass;
use ReflectionException;

/**
 * Attribute-driven CLI kernel.
 *  • Accepts an iterable list of command FQCNs (auto-generated by CommandFinder)
 *  • Also scans MonkeysLegion\Cli\Command\* for #[Command] attributes.
 */
final class CliKernel
{
    /** @var array<string, class-string<Command>> signature ⇒ class */
    private array $map = [];

    /**
     * CliKernel constructor.
     *
     * @param ContainerInterface $container Dependency injection container
     * @param iterable<class-string<Command>> $commands Explicitly passed command classes
     * @throws ReflectionException
     */
    public function __construct(
        private ContainerInterface $container,
        iterable $commands = [],
    ) {
        // 1. Register commands that were passed explicitly
        foreach ($commands as $class) {
            $this->register($class);
        }

        // 2. Fallback: auto-discover vendor commands
        $files = glob(__DIR__ . '/Command/*.php') ?: [];
        foreach ($files as $file) {
            require_once $file;
        }
        foreach (get_declared_classes() as $class) {
            if (
                str_starts_with($class, 'MonkeysLegion\\Cli\\Command\\') &&
                is_subclass_of($class, Command::class)
            ) {
                /** @var class-string<Command> $class */
                $this->register($class);
            }
        }
    }

    /**
     * Register a command class if it has the #[Command] attribute.
     *
     * @param class-string<Command> $class
     * @throws ReflectionException
     */
    private function register(string $class): void
    {
        $ref   = new ReflectionClass($class);
        $attrs = $ref->getAttributes(CommandAttr::class);
        if ($attrs === []) {
            return;
        }
        /** @var CommandAttr $meta */
        $meta = $attrs[0]->newInstance();
        $this->map[$meta->signature] = $class;
    }

    /**
     * Execute a command given argv.
     *
     * @param string[] $argv
     * @throws ReflectionException
     * @return int 0 on success, non-zero on error
     */
    public function run(array $argv): int
    {
        $sig = $argv[1] ?? 'list';

        if ($sig === 'list') {
            echo "Available commands:\n";
            foreach ($this->map as $signature => $class) {
                $desc = new ReflectionClass($class)
                    ->getAttributes(CommandAttr::class)[0]
                    ->newInstance()
                    ->description;
                echo "  {$signature}  -  {$desc}\n";
            }
            return 0;
        }

        if (! isset($this->map[$sig])) {
            fwrite(STDERR, "Command '{$sig}' not found.\n");
            return 1;
        }

        /** @var Command $command */
        $command = $this->container->get($this->map[$sig]);
        return $command();
    }
}
